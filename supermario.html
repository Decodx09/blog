<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Platformer Dark Theme</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: #000;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="game" width="960" height="540"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const TILE = 48;
    const GRAVITY = 1500;
    const player = {x:100,y:300,w:40,h:40,vx:0,vy:0,speed:220,jump:650,onGround:false};
    const keys = {};

    window.addEventListener('keydown', e=>keys[e.code]=true);
    window.addEventListener('keyup', e=>keys[e.code]=false);

    const levelCols = 20, levelRows = 12;
    const level = new Array(levelCols * levelRows).fill(0);
    function setTile(c,r,v){level[r*levelCols+c]=v;}
    function getTile(c,r){if(c<0||r<0||c>=levelCols||r>=levelRows) return 1; return level[r*levelCols+c];}

    for(let c=0;c<levelCols;c++) setTile(c, levelRows-1, 1);
    [ [5,9], [7,9], [12,8], [14,8] ].forEach(([c,r])=>setTile(c,r,2));

    const enemies = [{x:500,y:300,w:40,h:40,vx:-80,alive:true}];

    function collideRectTiles(x,y,w,h){
      const left=Math.floor(x/TILE), right=Math.floor((x+w-1)/TILE);
      const top=Math.floor(y/TILE), bottom=Math.floor((y+h-1)/TILE);
      const hits=[];
      for(let r=top;r<=bottom;r++){
        for(let c=left;c<=right;c++){
          hits.push({c,r,v:getTile(c,r)});
        }
      }
      return hits;
    }

    function drawParticles(x,y,color){
      ctx.fillStyle=color;
      for(let i=0;i<20;i++){
        let px = x + (Math.random()-0.5)*40;
        let py = y + (Math.random()-0.5)*40;
        ctx.fillRect(px, py, 2, 2);
      }
    }

    let last=performance.now();
    function loop(now){
      const dt=Math.min((now-last)/1000,1/15); last=now;
      if(keys['ArrowLeft']) player.vx=-player.speed; else if(keys['ArrowRight']) player.vx=player.speed; else player.vx=0;
      if((keys['ArrowUp']||keys['Space'])&&player.onGround){player.vy=-player.jump;player.onGround=false;}
      player.vy+=GRAVITY*dt;

      player.x+=player.vx*dt;
      collideRectTiles(player.x,player.y,player.w,player.h).forEach(h=>{
        if(h.v===1){if(player.vx>0)player.x=h.c*TILE-player.w;else if(player.vx<0)player.x=(h.c+1)*TILE;player.vx=0;}
      });

      player.y+=player.vy*dt;player.onGround=false;
      collideRectTiles(player.x,player.y,player.w,player.h).forEach(h=>{
        if(h.v===1){if(player.vy>0){player.y=h.r*TILE-player.h;player.vy=0;player.onGround=true;}else if(player.vy<0){player.y=(h.r+1)*TILE;player.vy=0;}}
        if(h.v===2){setTile(h.c,h.r,0);}
      });

      enemies.forEach(e=>{
        if(!e.alive) return;
        e.x+=e.vx*dt;
        if(e.x<0||e.x+e.w>canvas.width) e.vx*=-1;
        if(player.x<e.x+e.w&&player.x+player.w>e.x&&player.y<e.y+e.h&&player.y+player.h>e.y){
          if(player.vy>0){e.alive=false;player.vy=-player.jump*0.4;}else{player.x=100;player.y=300;}}
      });

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Draw tiles
      ctx.fillStyle='#444';
      for(let c=0;c<levelCols;c++){
        for(let r=0;r<levelRows;r++){
          if(getTile(c,r)===1) ctx.fillRect(c*TILE,r*TILE,TILE,TILE);
        }
      }

      // Coins
      ctx.fillStyle='yellow';
      for(let c=0;c<levelCols;c++){
        for(let r=0;r<levelRows;r++){
          if(getTile(c,r)===2) ctx.beginPath(),ctx.arc(c*TILE+TILE/2,r*TILE+TILE/2,8,0,Math.PI*2),ctx.fill();
        }
      }

      // Enemies
      enemies.forEach(e=>{if(e.alive){ctx.fillStyle='purple';ctx.fillRect(e.x,e.y,e.w,e.h);}});

      // Player glow
      ctx.globalCompositeOperation='lighter';
      drawParticles(player.x+player.w/2, player.y+player.h/2, 'rgba(255,50,50,0.8)');
      ctx.globalCompositeOperation='source-over';

      // Player
      ctx.fillStyle='red';
      ctx.fillRect(player.x,player.y,player.w,player.h);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
